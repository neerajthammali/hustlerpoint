/**
 * @fileoverview Firestore Security Rules for Hustler Point Hub.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure data access based on user authentication and
 * resource ownership. It enforces that users can only create, update, or
 * delete their own resources, while allowing public read access where
 * appropriate. The rules are designed to be adaptable and maintainable,
 * abstracting complex logic into helper functions.
 *
 * Data Structure:
 * - /articles/{articleId}: Stores article data. Root collection.
 * - /articles/{articleId}/comments/{commentId}: Stores comments related to a
 *   specific article. Subcollection of articles.
 * - /users/{userId}: Stores user data. Root collection.
 * - /categories/{categoryId}: Stores article categories. Root collection.
 *
 * Key Security Decisions:
 * - Users can create their user document with a matching `userId`.
 * - Articles are publicly readable, but only the author can modify them.
 * - Comments can be created by anyone on articles and are readable by everyone.
 *   Only the comment author can modify or delete their own comments.
 * - Listing operations are generally allowed for owner-specific collections.
 *
 * Denormalization for Authorization:
 *  - The ruleset relies on denormalization of the authorId (ownerId) on both
 *    the articles and comments collections to avoid costly `get()` operations in
 *    the security rules.
 *
 * Structural Segregation:
 *  - Publicly available data (articles) and private user data are stored in
 *    separate top-level collections to ensure clear access control boundaries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to articles, but restricts
     *   creation, updating, and deletion to the article's author.
     * @path /articles/{articleId}
     * @allow (get, list): if true; // Publicly readable.
     * @allow (create): if request.auth != null && request.resource.data.authorId == request.auth.uid; // Author can create.
     * @allow (update, delete): if isSignedIn() && isExistingOwner(resource.data.authorId); // Author can modify.
     * @deny (create): if request.auth == null // Must be signed in to create.
     * @principle Allows public read access to articles but enforces
     *   ownership for write operations.
     */
    match /articles/{articleId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow read: if true;
    }

    /**
     * @description Allows anyone to read comments, but restricts creation
     *   to authenticated users. Only the comment author can update or
     *   delete their comments.
     * @path /articles/{articleId}/comments/{commentId}
     * @allow (get, list): if true; // Publicly readable.
     * @allow (create): if isSignedIn() && request.resource.data.authorId == request.auth.uid; // Author can create.
     * @allow (update, delete): if isSignedIn() && isExistingOwner(resource.data.authorId); // Author can modify.
     * @deny (create): if !isSignedIn(); // Must be signed in to create.
     * @principle: Enforces comment ownership for write operations,
     *   allowing public read access.
     */
    match /articles/{articleId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows a user to create their own user document. Only the
     *   user can read, update, or delete their own document.
     * @path /users/{userId}
     * @allow (create): if request.auth.uid == userId; // Self-creation.
     * @allow (get, list): if isOwner(userId); // Owner can read.
     * @allow (update, delete): if isSignedIn() && isExistingOwner(userId); // Owner can modify.
     * @deny (create): if request.auth == null || request.auth.uid != userId; // Only self-creation allowed.
     * @principle Restricts access to a user's own data tree, enforcing
     *   strict ownership.
     */
    match /users/{userId} {
      allow create: if request.auth.uid == userId;
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow update, delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to categories. Creation,
     *   updating, and deletion are not allowed in this prototype.
     * @path /categories/{categoryId}
     * @allow get, list: if true; // Publicly readable.
     * @deny create, update, delete: if false;
     * @principle Allows public read access to categories, but disables write
     *   operations.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    // Helper functions

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the request is made by the owner of the resource.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the request is made by the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the request is made by the existing owner of the
     *   resource and that the resource exists.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the request is made by the owner and the resource
     *   exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}